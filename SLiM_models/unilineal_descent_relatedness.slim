initialize() {
	initializeSLiMModelType("nonWF");
	
	// record pedigrees
	initializeSLiMOptions(keepPedigrees = T);
	
	// output tree sequences
	initializeTreeSeq();
	
	// set mutation rate to 0
	// mutations will be added during the processing of the tree sequences
	initializeMutationRate(0);
	
	initializeSex("A");

	// working directory
	defineConstant("wd", "bash_wd");
	
	// number of villages
	defineConstant("N_VILLAGES", bash_Num_villages);
	
	// carrying capacity
	defineConstant("K", bash_carrying_capacity);
	
	// number of replicates
	defineConstant("N_REP", bash_Num_replicat);
	
	// chromosome sizes
	defineConstant("CHR_SIZE", bash_chr_size);
	
	// random fission
	defineConstant("RF", bash_random_fission);
	
	// fission threshold
	defineConstant("FITH", bash_fission_threshold);
	
	// probability for a descent group to move to another village after a split
	defineConstant("pM", bash_pM);
	
	// descent rule
	defineConstant("DESCENT", "bash_descent_rule");
	
	// female migration rate
	defineConstant("MF_RATIO", bash_mf_ratio);
	
	// male migration rate
	defineConstant("MM_RATIO", bash_mm_ratio);
	
	// variance of the normal law used to draw growth rates
	defineConstant("sd", bash_sd);
	
	// growth rate
	defineConstant("R", bash_growth_rate);
	
	// polygyny
	defineConstant("POLY", bash_polygyny);
	
	// transmission of growth rate to the new group
	defineConstant("TM", "bash_transmission");
	
	// output folder
	defineConstant("DirTable", "bash_dir_table");
	
	// set neutral mutations and convert to substitution
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeMutationType("m2", 1.0, "f", 0.0); // Y marker
	initializeMutationType("m3", 1.0, "f", 0.0); // mt marker
	
	initializeMutationType("m4", 1.0, "f", 0.0); // village 1 marker
	initializeMutationType("m5", 1.0, "f", 0.0); // village 2 marker
	initializeMutationType("m6", 1.0, "f", 0.0); // village 3 marker	
	initializeMutationType("m7", 1.0, "f", 0.0); // village 4 marker	
	initializeMutationType("m8", 1.0, "f", 0.0); // village 5 marker	
	
	initializeGenomicElementType("g1", m1, 1.0);
	
	defineConstant("UpperA", CHR_SIZE[0]);  // upper boundary for autosomes	
	defineConstant("LowerXY", CHR_SIZE[0] + 1);  // lower boundary for X/Y chromosomes
	defineConstant("UpperXY", CHR_SIZE[0] + CHR_SIZE[1] + 2);  // upper boundary for X/Y chromosomes	
	defineConstant("LowerMt", CHR_SIZE[0] + CHR_SIZE[1] + 3);  // lower boundary for mtDNA
	defineConstant("UpperMt", CHR_SIZE[0] + CHR_SIZE[1] + CHR_SIZE[2] + 4);  // upper boundary for mtDNA
	
	initializeGenomicElement(g1, 0, UpperMt);
	
	initializeRecombinationRate(c(1.1e-8, 0.5, 0, 0.5, 1e-8), c(UpperA, LowerXY, UpperXY, LowerMt, UpperMt), sex='M');
	initializeRecombinationRate(c(1.1e-8, 0.5, 1e-8, 0.5, 0), c(UpperA, LowerXY, UpperXY, LowerMt, UpperMt), sex='F');
	
	defineConstant("output", paste0(wd, "/Tables/Simulations_metrics/unilineal/regular/r=", R, '/sd=', sd, '/FT=', FITH, '/',  DirTable, "/"));
}

1 first() {
	start = clock();
	
	// load the burn-in simulation
	suppressWarnings(T);
	sim.readFromPopulationFile(paste0(c(wd, '/Burn_in/1Mb_chr/villages_unilineal_descent_burn_in_', asString(N_REP), '.trees')));
	inds = p1.individuals;
	nInds = size(inds);
	
	// load ancestors array
	if (RF == F) {
		if (DESCENT == 'patrilineal') {
			ID_temp = readFile(paste0(c(wd, '/Burn_in/1Mb_chr/patrilineal_ID_', asString(N_REP), '.txt')));
		}
		else {
			ID_temp = readFile(paste0(c(wd, '/Burn_in/1Mb_chr/matrilineal_ID_', asString(N_REP), '.txt')));
		}
		ID_temp = array(ID_temp, c(size(ID_temp), 1));
		ID = NULL;
		for (i in seq(0, nrow(ID_temp)-1)) {
			ID = rbind(ID, asInteger(strsplit(ID_temp[i,])));
		}
	}
	
	// split panmictic population into N groups
	N = integerDiv(nInds, K);
	
	// dictionary associating the group number with the column number of the last common ancestor in ID
	lastCommonAncestor = Dictionary();
	lastCommonAncestor.setValue("1", 1);
	
	for (i in 2:N) {
		// initialize column of last common ancestor to 1 for every group
		lastCommonAncestor.setValue(asString(i), 1);
		
		// individuals are randomly split into groups maintaining the sex ratio
		migrantsF = sample(p1.individuals[p1.individuals.sex == 'F'], asInteger(K/2));
		migrantsM = sample(p1.individuals[p1.individuals.sex == 'M'], asInteger(K/2));
		migrants = c(migrantsF,  migrantsM);
		
		newPop = community.subpopulationsWithIDs(i);
		newPop.takeMigrants(migrants);
	}
	
	sim.setValue('lastCommonAncestor', lastCommonAncestor);
	
	// attribute a growth rate to each group
	growthRate = rnorm(N, R, sd);
	sim.setValue("growthRate", growthRate);
	
	// initialize number of extinctions
	sim.setValue("nExtinctions", 0);
	
	// initialize number of fissions
	sim.setValue("nFissions", 0);
	
	// record fission
	sim.setValue("fission", c()); // TO-DO : encore utile ?
	
	// counter of groups
	sim.setValue("counter", N);
	
	// make villages
	villages = Dictionary();
	// transform ID array in Dictionary associating an array per village
	ID_temp = Dictionary();
	groups = seq(1, N);
	firstGroupIndex = 0;
	NLIN = integerDiv(N, N_VILLAGES);  // number of groups per village
	SUP_LIN = integerMod(N, N_VILLAGES);  // number of supplementary groups
	for (i in seq(1, N_VILLAGES)) {
		name = paste0(c("V", asString(i)));  // village's name
		if (SUP_LIN > 0) {
			lastGroupIndex = firstGroupIndex + NLIN;
			SUP_LIN = SUP_LIN - 1;
		}
		else {
			lastGroupIndex = firstGroupIndex + NLIN - 1;
		}
		groupVillage = groups[firstGroupIndex : lastGroupIndex];  // vector of groups for village i
		villages.setValue(name, groupVillage);
		firstGroupIndex = lastGroupIndex + 1;
		
		if (RF == F) {
			ID_village = NULL;
			for (group in groupVillage) {
				group = sim.subpopulations[sim.subpopulations.id == group];
				inds = group.individuals;
				// list of pedigreeID of individuals in the village
				if (DESCENT == 'patrilineal') {
					indsID = inds[inds.sex == 'M'].pedigreeID;
				}
				else {
					indsID = inds[inds.sex == 'F'].pedigreeID;
				}
				for (id in indsID) {
					ID_village = rbind(ID_village, ID[which(ID[,0] == id),]);
				}
			}
			ID_temp.setValue(name, ID_village);
		}
	}
	
	// record villages
	sim.setValue("villages", villages);
	
	// set village initial size
	K_village = K * NLIN;
	sim.setValue("K_village", K_village);
	
	// record ID array
	if (RF == F) {
		sim.setValue("ID", ID_temp);
	}
	
	// add markers for villages
	for (village in villages.allKeys) {
		ind = c();
		for (groupID in villages.getValue(village)) {
			group = sim.subpopulations[sim.subpopulations.id == groupID];
			indGroup = group.individuals[group.individuals.age < 2];
			ind = c(ind, indGroup);
		}
		
		if (village == 'V1') {
			ind.genomes.addNewMutation(m4, 0.0, 1);
		}
		if (village == 'V2') {
			ind.genomes.addNewMutation(m5, 0.0, 1);
		}
		if (village == 'V3') {
			ind.genomes.addNewMutation(m6, 0.0, 1);
		}
		if (village == 'V4') {
			ind.genomes.addNewMutation(m7, 0.0, 1);
		}
		if (village == 'V5') {
			ind.genomes.addNewMutation(m8, 0.0, 1);
		}
	}
	
	// time between beginning of a group and fission event = group depth
	depth = Dictionary();
	for (i in seq(1, groups[lastGroupIndex])) {
		depth.setValue(asString(i), 0);
	}
	sim.setValue('depth', depth);
	
	sim.setValue('migrantRatioList', c());
	
	print("Elapsed (split groups + create villages) : " + (clock() - start));
}

first() {
	// MIGRATION //
	print("MIGRATION");
	start = clock();
	
	// record adults
	adults = sim.subpopulations.individuals[sim.subpopulations.individuals.age < 2].pedigreeID;
	sim.setValue("adults", adults);
	
	villages = sim.getValue("villages");
	
	/// make lists of male and female migrants for each village ///
	migrantsF = Dictionary();
	migrantsM = Dictionary();
	for (key in villages.allKeys) {
		groupIDs = villages.getValue(key);
		groups = community.subpopulationsWithIDs(groupIDs);
		inds = groups.individuals[groups.individuals.age < 2];
		nInd = size(inds); // number of individuals
		IndF = inds[inds.sex=='F'];
		IndM = inds[inds.sex=='M'];
		nIndF = size(IndF); // number of females
		nIndM = size(IndM); // number of males
		
		nMigrantsF = asInteger(nIndF * MF_RATIO);  // number of female migrants
		nMigrantsM = asInteger(nIndM * MM_RATIO);  // number of male migrants
		migrantsF.setValue(key, sample(IndF, nMigrantsF).pedigreeID);
		migrantsM.setValue(key, sample(IndM, nMigrantsM).pedigreeID);
	}
	
	for (key in villages.allKeys) {
		// migration in a new group from a different village
		for (migrant in migrantsF.getValue(key))  {
			// sample a village that is different from the migrant's village
			possibleVillages = setDifference(villages.allKeys, key);
			sampledVillage = sample(possibleVillages, 1);
			// sample a group in the sampled village
			possibleGroup = villages.getValue(sampledVillage);
			sampledGroup = sample(possibleGroup, 1);
			dest = community.subpopulationsWithIDs(sampledGroup);
			// migration happens between groups from different villages
			dest.takeMigrants(sim.individualsWithPedigreeIDs(migrant));
		}
		
		for (migrant in migrantsM.getValue(key))  {
			// sample a village that is different from the migrant's village
			possibleVillages = setDifference(villages.allKeys, key);
			sampledVillage = sample(possibleVillages, 1);
			// sample a group in the sampled village
			possibleGroup = villages.getValue(sampledVillage);
			sampledGroup = sample(possibleGroup, 1);
			dest = community.subpopulationsWithIDs(sampledGroup);
			// migration happens between groups from different villages
			dest.takeMigrants(sim.individualsWithPedigreeIDs(migrant));
		}
	}
	print("Elapsed (migration) : " + (clock() - start));
}

reproduction(NULL, NULL) {
	// REPRODUCTION //
	print("REPRODUCTION");
	start = clock();
	self.active = 0;  // "reproduction" is called once per generation
	
	groups = sim.subpopulations;
	inds = groups.individuals[groups.individuals.age < 2];
	nInds = size(inds);
	nIndsF = size(inds[inds.sex=='F']);  // number of females
	nIndsM = size(inds[inds.sex=='M']);  // number of males
	
	//// reproduction within each village ////
	
	growthRate = sim.getValue("growthRate");
	villages = sim.getValue("villages");
	depth = sim.getValue("depth");
	nExtinctions = sim.getValue("nExtinctions");
	
	// initialize number of couples	
	nCouples = 0;
	
	// initialize lists of mothers and fathers IDs
	mot = c();
	fat = c();
	
	// initialize number of males that cannot find a female in a different group
	failedCouples = 0;
	
	// initialize number of single individuals
	singleInd = 0;
	
	// initialize list of failed children
	failedChildren = c();
	
	// initialize list of couples
	couples = c();
	
	// initialize custom ID arrays for males and females
	if (RF == F) {
		ID = sim.getValue("ID");
		ID_2 = Dictionary();
	}
	
	sMale = F;
	
	for (key in villages.allKeys) {
		couplesVillage = c();  // same as couples but only for the current village
		if (RF == F) {
			ID_village = ID.getValue(key);
			ID_village_2 = NULL;  // temporary ID_village in order to update it at each generation
		}
		
		// list of individuals in the village
		groups = villages.getValue(key);
		inds = community.subpopulationsWithIDs(groups).individuals[community.subpopulationsWithIDs(groups).individuals.age < 2];
		pop = community.subpopulationsWithIDs(groups);
		
		// initialize number of children done
		nChildrenDone = 0;
		
		// lists of single males and females in the village
		availableF = inds[inds.sex == 'F'];
		sizeF = size(availableF);
		if (POLY == F) {
			availableM = inds[inds.sex == 'M'];
		}
		else {
			// polygyny
			males = inds[inds.sex == 'M'];
			
			if (supermale == T) {
				if (sMale == F) {
					w = c(100, rep(1, asInteger(size(males) - 1)));
					weights = sample(w, size(males));
					sMale = T;
				}
				else {
					weights = rep(1, size(males));
				}
			}
			else {
				//weights = rpois(size(males), 1.2);
				weights = rgeom(size(males), 1/2);
			}
			availableM = sample(males, sizeF, replace = T, weights = weights);
		}
		
		/// form couples ///
		while (size(availableM) > 0 & size(availableF) > 0) {
			// choose a male
			husband = sample(availableM, 1);
			groupM = husband.subpopulation;
			
			// choose a female from a different group
			targetF = availableF[availableF.subpopulation != groupM];
			
			// if it is not possible, choose a female from the same group
			if (size(targetF)==0) {
				failedCouples = failedCouples + 1;
				wife = sample(availableF, 1);
			}
			else {
				wife = sample(targetF, 1);
			}
			
			// remove the couple from single males and females
			if (POLY == F) {
				availableM = setDifference(availableM, c(husband));
			}
			
			else {
				index = which(availableM == husband)[0];
				if (index == 0) {
					if (size(availableM) == 1) {
						avalaibleM = c();
					}
					else {
						availableM = availableM[1:(size(availableM)-1)];
					}
				}
				else if (index == size(availableM)-1) {
					availableM = availableM[0:(size(availableM)-2)];
				}
				else {
					availableM = c(availableM[0:(index-1)], availableM[(index+1):(size(availableM)-1)]);
				}
			}
			availableF = setDifference(availableF, c(wife));
			
			// update the list of couples in the group and initialize their number of children
			if (DESCENT == 'patrilineal') {
				couplesVillage = rbind(couplesVillage, c(key, husband.subpopulation.id, nCouples, husband.pedigreeID, wife.pedigreeID, 0));
			}
			else if (DESCENT == 'matrilineal') {
				couplesVillage = rbind(couplesVillage, c(key, wife.subpopulation.id, nCouples, husband.pedigreeID, wife.pedigreeID, 0));
			}
			nCouples = nCouples + 1;
		}
		
		// update single individuals
		singleInd = singleInd + size(availableM) + size(availableF);
		
		// Compute probabilities of reproduction
		groupCurrentGen = asInteger(unique(couplesVillage[,1]));
		growthRateVillage = sapply(groupCurrentGen, "growthRate[applyValue - 1];");
		
		print("Elapsed (reproduction villages, proba) : " + (clock() - start));
		start = clock();
		
		K_village = sim.getValue("K_village");
		K_village = asInteger(K_village * exp(R)); // exponential growth
		
		// initialize number of couples
		nCouples_done = 0;
		// compute breeding weights for each descent group
		index=0;
		if (DESCENT == 'patrilineal') {
			breedingWeights = sapply(groupCurrentGen, "index = index + 1;p = community.subpopulationsWithIDs(applyValue); 2 * size(p.individuals[p.individuals.sex == 'M' & p.individuals.age < 2]) * exp(growthRateVillage[index-1]);");
		}
		else if (DESCENT == 'matrilineal') {
			breedingWeights = sapply(groupCurrentGen, "index = index + 1;p = community.subpopulationsWithIDs(applyValue); 2 * size(p.individuals[p.individuals.sex == 'F' & p.individuals.age < 2]) * exp(growthRateVillage[index-1]);");
		}
		// sample K_village groups
		sampledGroup = sample(x = groupCurrentGen, size = K_village, replace = T, weights = breedingWeights);
		// sample 1 couple for each chosen group
		couplesIndex = sapply(sampledGroup, "sample(couplesVillage[which(couplesVillage[,1] == applyValue),][,2], 1);");
		sampledCouples = sapply(couplesIndex, "couplesVillage[which(couplesVillage[,2] == applyValue),][,3:4];");
		doneCouples = t(array(sapply(sampledCouples, "inds[inds.pedigreeID == applyValue];"), c(2, asInteger(size(sampledCouples)/2))));
		
		// active groups in the current generation
		groupCurrentGen = asInteger(unique(sampledGroup));
		
		// Compute number of extinctions
		extinctGroup = setDifference(groups, groupCurrentGen);
		nExt = size(extinctGroup);
		if (nExt > 0) {
			print('Extinction !');
			
			// update number of extinctions
			nExtinctions = nExtinctions + nExt;
			sim.setValue("nExtinctions", nExtinctions);
			
			// update villages
			villages.setValue(key, groupCurrentGen); // update key in villages
			
			// update depth
			for (keyExt in extinctGroup) {
				depth.setValue(asString(keyExt), NULL);
			}
			
			//update growth rates
			for (extGroup in extinctGroup) {
				extIndex = extGroup - 1;
				growthRate[extIndex] = -1;
			}
		}
		
		print("Elapsed (reproduction villages, form couples) : " + (clock() - start));
		start = clock();
		
		// initialize couple index
		coupleIndex = 0;
		
		// make K_village children //
		while (nChildrenDone < K_village) {
			// get father and mother
			father = c(doneCouples[coupleIndex, 0]);
			mother = c(doneCouples[coupleIndex, 1]);
			
			// choose the group of the father if patrilineal (or mother if matrilineal)
			// the child belongs to his father's group (patrilineal) or to his mother's group (matrilineal)
			pop = ifelse(DESCENT == 'patrilineal', father.subpopulation, mother.subpopulation);
			
			// make child
			// sex is defined so that the sex ratio = 0.5
			if (integerMod(coupleIndex, 2) == 0) {
				child = pop.addCrossed(mother, father, sex = 'F');
			}
			else {
				child = pop.addCrossed(mother, father, sex = 'M');
			}
			
			wrongSex = F;
			
			// females should not have a Y and have a mt and males should have a Y and not a mt
			if (child.genome2.containsMarkerMutation(m2, UpperXY)) {
				if (child.genome1.containsMarkerMutation(m3, UpperMt)) {
					failedChildren = c(failedChildren, child.pedigreeID);
					wrongSex = T;
				}
				else if (child.sex == 'F') {
					failedChildren = c(failedChildren, child.pedigreeID);
					wrongSex = T;
				}
			}
			else {
				if (!child.genome1.containsMarkerMutation(m3, UpperMt)) {
					failedChildren = c(failedChildren, child.pedigreeID);
					wrongSex = T;
				}
				else if (child.sex == 'M') {
					failedChildren = c(failedChildren, child.pedigreeID);
					wrongSex = T;
				}
			}
			
			if (wrongSex == F) {
				// increment couple index
				coupleIndex = coupleIndex + 1;
				
				// increment number of children for the couple
				nChildrenDone = nChildrenDone + 1;
				rowIndex = which(couplesVillage[,3] == father.pedigreeID);
				couplesVillage[rowIndex,5] = asInteger(couplesVillage[rowIndex,5]) + 1;
				
				// increment lists of mothers and fathers
				fat = unique(c(fat, father));
				mot = unique(c(mot, mother));
				
				// matrices of IDs
				if (RF == F) {
					if (DESCENT == 'matrilineal' & child.sex == 'F') {
						mother_ID = asString(mother.pedigreeID);
						// the daughter inherits the custom ID of her mother + supplementary number corresponding to the number of the child in the family
						ID_village_mother = ID_village[which(ID_village[,0] == mother_ID),];
						// if mother is a migrant, give the ID of another individual in the group
						counter = 0;
						while (size(ID_village_mother) == 0) {
							mother = mother.subpopulation.sampleIndividuals(1, sex = 'F', maxAge = 1);
							ID_village_mother = ID_village[which(ID_village[,0] == asString(mother.pedigreeID)),];
							counter = counter + 1;
							if (counter > size(mother.subpopulation.individuals[mother.subpopulation.individuals.sex == 'F' & mother.subpopulation.individuals.age == 1]) -1) {
								newMotherID = sample(ID_village[,0], 1);
								ID_village_mother = ID_village[which(ID_village[,0] == newMotherID),];
							}
						}
						value = c(ID_village_mother, mother.reproductiveOutput - 1);
						ID_village_2 = rbind(ID_village_2, c(asString(child.pedigreeID), value[2:size(value)-1]));
					}
					else if (DESCENT == 'patrilineal' & child.sex == 'M') {
						father_ID = asString(father.pedigreeID);
						// the son inherits the custom ID of his father + supplementary number corresponding to the number of the child in the family
						ID_village_father = ID_village[which(ID_village[,0] == father_ID),];
						// if father is a migrant, give the ID of another individual in the group
						
						counter = 0;
						while (size(ID_village_father) == 0) {
							newFather = father.subpopulation.sampleIndividuals(1, sex = 'M', maxAge = 1);
							ID_village_father = ID_village[which(ID_village[,0] == asString(newFather.pedigreeID)),];
							counter = counter + 1;
							if (counter > size(father.subpopulation.individuals[father.subpopulation.individuals.sex == 'M']) -1) {
								newFatherID = sample(ID_village[,0], 1);
								ID_village_father = ID_village[which(ID_village[,0] == newFatherID),];
							}
						}
						value = c(ID_village_father, father.reproductiveOutput - 1);
						ID_village_2 = rbind(ID_village_2, c(asString(child.pedigreeID), value[2:size(value)-1]));
					}
				}
			}
		}
		
		// extinction of non reproductive groups
		reproGroup = asInteger(unique(couplesVillage[,1]));
		extinctGroup = setDifference(groupCurrentGen, reproGroup);
		nExt = size(extinctGroup);
		if (nExt > 0) {
			print('Extinction !');
			
			// update number of extinctions
			nExtinctions = nExtinctions + nExt;
			sim.setValue("nExtinctions", nExtinctions);
			
			// update villages
			villages.setValue(key, reproGroup);
			
			// update depth
			for (keyExt in extinctGroup) {
				depth.setValue(asString(keyExt), NULL);
			}
			
			//update growth rates
			for (extGroup in extinctGroup) {
				extIndex = extGroup - 1;
				growthRate[extIndex] = -1;
			}
		}
		// update couples
		couples = rbind(couples, couplesVillage);
		if (RF == F) {
			ID_2.setValue(key, ID_village_2);
		}
		print("Elapsed (reproduction villages, make children) : " + (clock() - start));
		start = clock();
		
		// output demographic metrics
		groups = villages.getValue(key);
		pGroup = sapply(groups, "growthRate[applyValue - 1];");
		denom = sum(pGroup);
		proba = pGroup/denom;
		for (i in seq(0, size(groups) - 1)) {
			couplesGroup = couples[which(couples[,1] == groups[i]),];
			if (size(couplesGroup) == 0) {
				nChildGroup = 0;
			}
			else {
				nChildGroup = sum(asInteger(couplesGroup[,5]));
			}
			group = community.subpopulationsWithIDs(groups[i]);
			if (DESCENT == 'patrilineal') {
				sizeGroup = 2*size(group.individuals[group.individuals.sex == 'M' & group.individuals.age < 2]);
			}
			else if (DESCENT == 'matrilineal') {
				sizeGroup = 2*size(group.individuals[group.individuals.sex == 'F' & group.individuals.age < 2]);
			}
			line = paste("bash_Num_replicat", community.tick, key, groups[i], nChildGroup, pGroup[i], proba[i], sizeGroup);
			writeFile(paste0(output, "proba_lin.txt"), line, append = T);
		}
		meanR = mean(pGroup/mean(pGroup));
		varR = var(pGroup/mean(pGroup));
		line = paste("bash_Num_replicat", community.tick, key, meanR, varR);
		writeFile(paste0(output, "growthRates.txt"), line, append = T);
	}
	
	for (i in seq(0, size(couples[,0])-1)) {
		couple = couples[i,];
		nChildren = asInteger(couple[,5]);
		group = couple[,1];
		line = paste("bash_Num_replicat", community.tick, group, nChildren);
		writeFile(paste0(output, "nChildrenPerCouple.txt"), line, append = T);
	}
	
	// increment group depth
	newDepth = depth;
	keys = sapply(depth.allKeys, "newDepth.setValue(applyValue, depth.getValue(applyValue) + 1); applyValue;");
	sim.setValue("depth", newDepth);
	
	mothers = size(mot)/nIndsF*100;
	fathers = size(fat)/nIndsM*100;
	nCouples = size(mot);
	sim.setValue('mothers', mothers);
	sim.setValue('fathers', fathers);
	sim.setValue('failedCouples', failedCouples);
	sim.setValue('%singleInd', singleInd/nInds * 100);
	sim.setValue('failedChildren', failedChildren);
	sim.setValue('nCouples', nCouples);
	sim.setValue('couples', couples);
	if (RF == F) {
		sim.setValue("ID", ID_2);
	}
	sim.setValue("villages", villages);
	sim.setValue("K_village", K_village);
	sim.setValue("growthRate", growthRate);
}

early() {
	// kill failed children
	failedChildren = sim.getValue("failedChildren");
	if (!isNULL(failedChildren)) {
		sim.killIndividuals(sim.individualsWithPedigreeIDs(failedChildren));
	}
}

1:20016 early() {
	// non-overlapping generations : we kill parents
	adults = sim.subpopulations.individuals[sim.subpopulations.individuals.age > 0];
	if (!isNULL(adults)) {
		sim.killIndividuals(adults);
	}
}

20021:20036 early() {
	// non-overlapping generations : we kill parents
	adults = sim.subpopulations.individuals[sim.subpopulations.individuals.age > 0];
	if (!isNULL(adults)) {
		sim.killIndividuals(adults);
	}
}

20041:20056 early() {
	// non-overlapping generations : we kill parents
	adults = sim.subpopulations.individuals[sim.subpopulations.individuals.age > 0];
	if (!isNULL(adults)) {
		sim.killIndividuals(adults);
	}
}

20061:20076 early() {
	// non-overlapping generations : we kill parents
	adults = sim.subpopulations.individuals[sim.subpopulations.individuals.age > 0];
	if (!isNULL(adults)) {
		sim.killIndividuals(adults);
	}
}

20081:20096 early() {
	// non-overlapping generations : we kill parents
	adults = sim.subpopulations.individuals[sim.subpopulations.individuals.age > 0];
	if (!isNULL(adults)) {
		sim.killIndividuals(adults);
	}
}

20001:20100 early() {
	// FISSIONS / EXTINCTIONS //
	print("FISSIONS / EXTINCTIONS");
	start = clock();
	
	counter = sim.getValue("counter");
	nFissions = sim.getValue("nFissions");
	nExtinctions = sim.getValue("nExtinctions");
	villages = sim.getValue("villages");
	if (RF == F) {
		ID = sim.getValue("ID");
		groupDepth = c();
		pairwiseDepth = c();
	}
	growthRate = sim.getValue("growthRate");
	depth = sim.getValue("depth");
	migrantRatioList = sim.getValue('migrantRatioList');
	K_village = sim.getValue('K_village');
	fissionTime = c();
	
	// unfriendly fission : list splitting groups and their village of origin
	splittingGroups = c();
	sourceVillages = c();
	
	for (village in villages.allKeys) {
		pops = community.subpopulationsWithIDs(asInteger(villages.getValue(village)));
		nIndsM = size(pops.individuals[pops.individuals.sex == 'M' & pops.individuals.age == 0]); // nb of males in the village
		
		if (RF == F) {
			ID_village = ID.getValue(village);
		}
		
		for (subpop in pops) {
			inds = subpop.individuals[subpop.individuals.age == 0];
			nInds = size(inds);
			nMales = size(inds[inds.sex == 'M']); // nb of males in the descent group
			
			// fission event if the size of the descent group is above FITH and if the last fission event is older than 3 generations
			if (nInds >= FITH & depth.getValue(asString(subpop.id)) > 3) {
				print("Fission !");
				nFissions = nFissions + 1;
				
				// update depth and counter
				fissionTime = c(fissionTime, depth.getValue(asString(subpop.id)));
				depth.setValue(asString(subpop.id), 0);
				counter = counter + 1;
				depth.setValue(asString(counter), 0);
				
				// modify growth rates for the resulting groups
				if (TM == "half") {
					newGrowthRate = rnorm(1, growthRate[subpop.id - 1], sd);
					growthRate[subpop.id - 1] = newGrowthRate;
					growthRate = c(growthRate, rnorm(1, R, 0.1));
				}
				
				else {
					newGrowthRate = rnorm(1, growthRate[subpop.id - 1], sd);
					growthRate[subpop.id - 1] = rnorm(1, growthRate[subpop.id - 1], sd);
					growthRate = c(growthRate, newGrowthRate);
				}
				
				if (DESCENT == 'patrilineal') {
					ind = inds[inds.sex == 'M'];
					oppositSexInd = inds[inds.sex == 'F'];
				}
				else if (DESCENT == 'matrilineal') {
					ind = inds[inds.sex == 'F'];
					oppositSexInd = inds[inds.sex == 'M'];
				}
				
				/// lineal fission ///
				if (RF == F) {
					lastCommonAncestor = sim.getValue('lastCommonAncestor');
					
					// new ID matrix for individuals of the group
					new_ID = NULL;
					// reduce the number of values in ID vector : keep only generations where there are different ancestors
					for (id in ind.pedigreeID) {
						ID_village_individual = ID_village[which(ID_village[,0] == id),];
						new_ID = rbind(new_ID, ID_village[which(ID_village[,0] == id),]);
					}
					
					// find last common ancestor for the group
					idx = lastCommonAncestor.getValue(asString(subpop.id));
					ancestors = unique(new_ID[,idx]);
					nAncestors = size(ancestors);
					while (nAncestors == 1 & idx <= size(new_ID[0,])) {
						ancestors = unique(new_ID[,idx]);
						nAncestors = size(ancestors);
						idx = idx + 1;
						if (nAncestors > 1) {
							idx = idx - 1;
						}
					}
					
					// update group depth
					groupDepth = c(groupDepth, size(new_ID[0,]) - idx);
					
					// update lastCommonAncestor
					lastCommonAncestor.setValue(asString(subpop.id), idx);
					
					// initialize new groups
					group1 = c();
					group2 = c();
					
					// initialize number of descendants for each new group
					nGroup1 = 0;
					nGroup2 = 0;
					nDescendants = c();
					
					for (ancestor in ancestors) {
						nDescendants = c(nDescendants, size(which(new_ID[,idx] == ancestor)));
					}
					ordered_ancestors = order(nDescendants, ascending = F);
					
					for (index in ordered_ancestors) {
						if (nGroup1 <= nGroup2) {
							group1 = c(group1, new_ID[which(new_ID[,idx] == ancestors[index]),][,0]);
							nGroup1 = nGroup1 + nDescendants[index];
						}
						else {
							group2 = c(group2, new_ID[which(new_ID[,idx] == ancestors[index]),][,0]);
							nGroup2 = nGroup2 + nDescendants[index];
						}
					}
					
					// the smaller group is the new group
					if (nGroup1 < nGroup2) {
						newGroup = group1;
					}
					else {
						newGroup = group2;
					}
					migrants = sim.individualsWithPedigreeIDs(asInteger(newGroup));
					ratio_migrants = size(migrants)/(nGroup1 + nGroup2);
					
					// add individuals of opposite sex to migrants
					companions = sample(oppositSexInd, asInteger(ratio_migrants*size(oppositSexInd)));
					migrants = c(migrants, companions);
					
					//update lastCommonAncestor
					nCol = lastCommonAncestor.getValue(asString(subpop.id));
					lastCommonAncestor.setValue(asString(counter), nCol);
					sim.setValue('lastCommonAncestor', lastCommonAncestor);
				}
				
				/// random fission ///
				else {
					// we draw a number of migrants
					nInd = size(ind);
					// draw the proportion of migrants in a truncated normal law of mean 0.5 and sd = 0.5
					ratio_migrants = rnorm(1, 0.5, 0.5);
					while (ratio_migrants < 0 | ratio_migrants > 1) {
						ratio_migrants = rnorm(1, 0.5, 0.5);
					}
					// the smaller group is the new group
					if (ratio_migrants > 0.5) {
						ratio_migrants = 1 - ratio_migrants;
					}
					nMigrants = asInteger(ratio_migrants*nInd);
					migrants = sample(ind, nMigrants);
					
					// add individuals of opposite sex to migrants
					companions = sample(oppositSexInd, asInteger(ratio_migrants*size(oppositSexInd)));
					migrants = c(migrants, companions);
				}
				
				migrantRatioList = c(migrantRatioList, ratio_migrants);
				
				// migration in a new group
				group = community.subpopulationsWithIDs(counter);
				group.takeMigrants(migrants);
				
				randomN = runif(1, 0, 1);
				// if fission is not friendly, the new group goes to another village with a probability pM
				if (randomN < pM) {
					splittingGroups = c(splittingGroups, counter);
					sourceVillages = c(sourceVillages, village);
				}
				// if fission is friendly, the new group stays in the same village
				else {
					newGroup = Dictionary(village, c(counter));
					// add new group to its parent village
					villages.appendKeysAndValuesFrom(newGroup);
				}
				
				// record fission
				fission = sim.getValue("fission");
				source = subpop.id;
				new = counter;
				fission = rbind(c(source, new), fission);
				
				sim.setValue("counter", counter);
				sim.setValue("fission", fission);
			}
			
			/// extinction (descent group without males) ///
			if (nMales == 0) {
				print('Extinction!');
				
				nExtinctions = nExtinctions + 1;
				
				// include remaining females in another group if necessary
				remainingInds = subpop.individuals[subpop.individuals.age == 0];
				if (size(remainingInds) > 0) {
					possibleGroups = setDifference(pops, subpop);
					newGroup = sample(possibleGroups, 1);
					newGroup.takeMigrants(remainingInds);
				}
				
				// update villages
				groupID = villages.getValue(village);
				groups = setDifference(groupID, subpop.id);
				villages.setValue(village, groups);
				
				// update depth and growthRate
				depth.setValue(asString(subpop.id), NULL);
				growthRate[subpop.id - 1] = -1;
			}
		}
	}
	
	if (!isNULL(sourceVillages)) {
		for (i in seq(0, size(sourceVillages)-1)) {
			sourceVillages[i] = strsplit(sourceVillages[i], "V")[1];
		}
		sourceVillages = asInteger(sourceVillages);
		tabSourceVillages = tabulate(sourceVillages);
		orderedSourceVillages = order(tabSourceVillages, ascending = F);
		
		countVillages = Dictionary();
		positions = Dictionary();
		pos = 0;
		
		for (i in sourceVillages) {
			if (tabSourceVillages[i] > 0) {
				countVillages.setValue(asString(i), tabSourceVillages[i]);
				positions.setValue(asString(pos), i);
			}
			pos = pos + 1;
		}
		
		sortedSourceVillages = c();
		original_pos = c();
		
		for (i in orderedSourceVillages) {
			if (match(asString(i), countVillages.allKeys) < 0) {
				next;
			}
			sortedSourceVillages = c(sortedSourceVillages, rep(i, countVillages.getValue(asString(i))));
			for (p in positions.allKeys) {
				val = positions.getValue(p);
				if (val == i) {
					original_pos = c(original_pos, p);
					positions.setValue(p, NULL);
					next;
				}
			}
		}
		
		// reorder groups
		original_pos = asInteger(original_pos);
		sortedSplittingGroups = sapply(original_pos, "splittingGroups[applyValue];");
		
		// sample a village
		originalList = sortedSourceVillages;
		remaining_indices = seq(0, size(sortedSourceVillages)-1);
		for (i in seq(0, size(originalList)-1)) {
			original_value = originalList[i];
			if (sortedSourceVillages[i] != original_value) {
				next;
			}
			available_indices = F;
			
			for (j in seq(0, size(sortedSourceVillages)-1)) {
				if (j == i) {
					next;
				}
				if (sortedSourceVillages[j] != original_value & sortedSourceVillages[i] != originalList[j]) {
					// swap values
					sortedSourceVillages[i] = sortedSourceVillages[j];
					sortedSourceVillages[j] = original_value;
					remaining_indices = setDifference(remaining_indices, j);
					remaining_indices = setDifference(remaining_indices, i);
					available_indices = T;
					break;
				}
			}
			if (available_indices == F) {
				sampleIndex = sample(setDifference(seq(1, 5), original_value), 1);
				sortedSourceVillages[i] = sampleIndex;
				sampleRemainingIndex = sample(remaining_indices, 1);
				remaining_indices = setDifference(remaining_indices, sampleRemainingIndex);
			}
		}
		
		for (i in seq(0, size(sortedSplittingGroups)-1)) {
			newVillage = paste0("V", sortedSourceVillages[i]);
			groupID = sortedSplittingGroups[i];
			newGroup = Dictionary(newVillage, c(groupID));
			// add new group to its host village
			villages.appendKeysAndValuesFrom(newGroup);
			
			if (RF == F) {
				// update ID
				ID_newVillage = ID.getValue(newVillage);
				previousVillage = paste0("V", originalList[i]);
				print(previousVillage);
				ID_previousVillage = ID.getValue(previousVillage);
				for (ind in community.subpopulationsWithIDs(groupID).individuals.pedigreeID) {
					ID_newVillage = rbind(ID_newVillage, ID_previousVillage[which(ID_previousVillage[,0] == ind),]);
					//ID_previousVillage[which(ID_previousVillage[,0] == ind),] = NULL;
				}
				//ID.setValue(previousVillage, ID_previousVillage);
				ID.setValue(newVillage, ID_newVillage);
			}
		}
		if (RF == F) {
			sim.setValue("ID", ID);
		}
	}
	
	/// remove unactive groups ///
	activeGroup = sim.subpopulations[sim.subpopulations.individualCount > 0];
	realGroup = c();
	for (village in villages.allKeys) {
		realGroup = c(realGroup, community.subpopulationsWithIDs(asInteger(villages.getValue(village))));
	}
	extinctGroup = setDifference(activeGroup, realGroup);
	for (group in extinctGroup) {
		group.removeSubpopulation();
	}
	
	sim.setValue("villages", villages);
	sim.setValue("depth", depth);
	sim.setValue("growthRate", growthRate);
	sim.setValue('migrantRatioList', migrantRatioList);
	sim.setValue('nFissions', nFissions);
	sim.setValue("nExtinctions", nExtinctions);
	if (RF == F) {
		sim.setValue("groupDepth", groupDepth);
		//sim.setValue("pairwiseDepth", pairwiseDepth);
	}
	sim.setValue("fissionTime", fissionTime);
	print("Elapsed (Fissions/Extinctions) : " + (clock() - start));
}

20001:20100	late() {
	/// output ///
	subpop = sim.subpopulations;
	
	if (community.tick % 2 == 0) {
		nIndTotal = sum(size(subpop.individuals[subpop.individuals.age == 0]));
		
		nGroups = size(subpop[subpop.individualCount > 0]);
		
		// Nb of fissions (cumulated)
		nFissions = sim.getValue("nFissions");
		
		// Nb of extinctions (cumulated)
		nExtinctions = sim.getValue("nExtinctions");
		
		mothers = sim.getValue("mothers");
		fathers =  sim.getValue("fathers");
		indPerGroup = size(subpop.individuals[subpop.individuals.age == 0])/nGroups;
		varIndPerGroup = var(subpop.individualCount/nGroups);
		femalePerGroup = size(subpop.individuals[subpop.individuals.sex == 'F' & subpop.individuals.age == 0])/nGroups;
		failedCouples = sim.getValue("failedCouples");
		singleInd = sim.getValue("%singleInd");
		couples = sim.getValue("couples");
		meanNbChild = mean(c(asInteger(couples[,5])));
		varNbChild = var(c(asInteger(couples[,5])));
		
		// time between 2 fission events
		fissionTime = sim.getValue("fissionTime");
		if (size(fissionTime) > 0) {
			meanFissionTime = mean(fissionTime);
			varFissionTime = var(fissionTime);
			for (i in fissionTime){
				line = paste("bash_Num_replicat", community.tick, i);
				writeFile(paste0(output, "fissionTime.txt"), line, append = T);
			}
		}
		else {
			meanFissionTime = NAN;
			varFissionTime = NAN;
		}
		
		if (RF == F) {
			groupDepth = sim.getValue("groupDepth");
			if (isNULL(groupDepth)) {
				meanDepth = NAN;
				varDepth = NAN;
			}
			else {
				meanDepth = mean(groupDepth);
				varDepth = var(groupDepth);
				for (d in groupDepth){
					line = paste("bash_Num_replicat", community.tick, d);
					writeFile(paste0(output, "groupDepth.txt"), line, append = T);
				}
			}
		}
		else {
			meanDepth = NAN;
			varDepth = NAN;
		}
		
		migrantRatioList = sim.getValue('migrantRatioList');
		if (size(migrantRatioList) == 0) {
			meanRatioMigrants = NAN;
			varRatioMigrants = NAN;
		}
		else {
			meanRatioMigrants = mean(migrantRatioList);
			varRatioMigrants = var(migrantRatioList);
		}
		
		line = paste("bash_Num_replicat", community.tick, nIndTotal, nFissions, nExtinctions, nGroups, fathers, indPerGroup, varIndPerGroup, femalePerGroup, mothers, failedCouples, singleInd, meanNbChild, varNbChild, meanDepth, varDepth, meanRatioMigrants, varRatioMigrants, meanFissionTime, varFissionTime);
		writeFile(paste0(output, "metrics.txt"), line, append = T);
	}
}

20020:20100 late() {
	if (community.tick % 20 == 0) {
		villages = sim.getValue("villages");
		for (village in villages.allKeys) {
			groupIDs = villages.getValue(village);
			groups = community.subpopulationsWithIDs(groupIDs);
			
			pairwise_relatednessM = c();
			pairwise_relatednessF = c();
			pairwise_relatednessM_sampled = c();
			pairwise_relatednessF_sampled = c();
			
			males = groups.individuals[groups.individuals.sex == 'M' & groups.individuals.age > 0 & groups.individuals.age < 4];
			for (male1 in seq(0, size(males)-2)) {
				other_males = males[(male1 + 1): (size(males) - 1)];
				rel = males[male1].relatedness(other_males);
				pairwise_relatednessM = c(pairwise_relatednessM, rel);
			}
			
			sampled_males = sample(males, 10);
			for (male1 in seq(0, size(sampled_males)-2)) {
				other_males = sampled_males[(male1 + 1): (size(sampled_males) - 1)];
				rel = sampled_males[male1].relatedness(other_males);
				pairwise_relatednessM_sampled = c(pairwise_relatednessM_sampled, rel);
			}
			
			sampled_males_mothers_ID = c();
			for (male1 in seq(0, size(sampled_males)-1)) {
				sampled_males_mothers_ID = c(sampled_males_mothers_ID, sampled_males[male1].pedigreeParentIDs[0]);
			}
			sampled_males_mothers = sim.individualsWithPedigreeIDs(sampled_males_mothers_ID);
			
			females = groups.individuals[groups.individuals.sex == 'F' & groups.individuals.age > 0 & groups.individuals.age < 4];
			for (female1 in seq(0, size(females)-2)) {
				other_females = females[(female1 + 1): (size(females) - 1)];
				rel = females[female1].relatedness(other_females);
				pairwise_relatednessF = c(pairwise_relatednessF, rel);
			}
			
			sampled_females = sample(females, 10);
			for (female1 in seq(0, size(sampled_females)-2)) {
				other_females = sampled_females[(female1 + 1): (size(sampled_females) - 1)];
				rel = sampled_females[female1].relatedness(other_females);
				pairwise_relatednessF_sampled = c(pairwise_relatednessF_sampled, rel);
			}
			
			// frequency of 1st, 2nd and 3rd degree relatedness
			relFreqM = size(pairwise_relatednessM[pairwise_relatednessM > 0])/size(pairwise_relatednessM);
			relFreqF = size(pairwise_relatednessF[pairwise_relatednessF > 0])/size(pairwise_relatednessF);
			sampleRelFreqM = size(pairwise_relatednessM_sampled[pairwise_relatednessM_sampled > 0])/size(pairwise_relatednessM_sampled);
			sampleRelFreqF = size(pairwise_relatednessF_sampled[pairwise_relatednessF_sampled > 0])/size(pairwise_relatednessF_sampled);
			
			// frequency of 1st degree relatedness
			relFirstM = size(pairwise_relatednessM[pairwise_relatednessM == 0.5])/size(pairwise_relatednessM);
			relFirstF = size(pairwise_relatednessF[pairwise_relatednessF == 0.5])/size(pairwise_relatednessF);
			sampleRelFirstM = size(pairwise_relatednessM_sampled[pairwise_relatednessM_sampled == 0.5])/size(pairwise_relatednessM_sampled);
			sampleRelFirstF = size(pairwise_relatednessF_sampled[pairwise_relatednessF_sampled == 0.5])/size(pairwise_relatednessF_sampled);
			
			// mean relatedness
			meanRelM = mean(pairwise_relatednessM);
			meanRelF = mean(pairwise_relatednessF);
			sampleMeanRelM = mean(pairwise_relatednessM_sampled);
			sampleMeanRelF = mean(pairwise_relatednessF_sampled);
			
			line = paste("bash_Num_replicat", community.tick, relFreqM, relFreqF, meanRelM, meanRelF, relFirstM, relFirstF,
				sampleRelFreqM, sampleRelFreqF, sampleMeanRelM, sampleMeanRelF, sampleRelFirstM, sampleRelFirstF);
			writeFile(paste0(output, "relatedness.txt"), line, append = T);
			
			relatives = c(sampled_males, sampled_females, sampled_males_mothers);
			for (i in relatives) {
				pedID = i.pedigreeID;
				writeFile("bash_Num_replicat/pedigreeID_village.txt", paste(asString(pedID), village, community.tick), append = T);
			}
			
			sim.treeSeqRememberIndividuals(relatives);
			
			// if females are burried with their father
			females = sim.subpopulations.individuals[sim.subpopulations.individuals.sex == "F"];
			femaleRelatives = c();
			pairwise_relatednessF = c();
			allmales = groups.individuals[groups.individuals.sex == 'M' & groups.individuals.age > 0];
			for (male1 in allmales[allmales.age > 1]) {
				// daughters
				relFemales = females.relatedness(male1);
				firstDegFemalesIndex = which(relFemales == 0.5);
				firstDegFemales = females[firstDegFemalesIndex];
				femaleRelatives = c(femaleRelatives, firstDegFemales[firstDegFemales.age == male1.age - 1]);
			}
			femaleRelatives = unique(femaleRelatives);
			
			for (female1 in seq(0, size(femaleRelatives)-2)) {
				other_females = femaleRelatives[(female1 + 1): (size(femaleRelatives) - 1)];
				rel = femaleRelatives[female1].relatedness(other_females);
				pairwise_relatednessF = c(pairwise_relatednessF, rel);
			}
			
			// frequency of 1st, 2nd and 3rd degree relatedness
			relFreqF = size(pairwise_relatednessF[pairwise_relatednessF > 0])/size(pairwise_relatednessF);
			
			// frequency of 1st degree relatedness
			relFirstF = size(pairwise_relatednessF[pairwise_relatednessF == 0.5])/size(pairwise_relatednessF);
			
			// mean relatedness
			meanRelF = mean(pairwise_relatednessF);
			
			line = paste("bash_Num_replicat", community.tick, relFreqM, relFreqF, meanRelM, meanRelF, relFirstM, relFirstF);
			writeFile(paste0(output, "relatedness_father.txt"), line, append = T);
			
			sampled_males = sample(males, 10);
			sampled_females = sample(femaleRelatives, 10);
			
			sampled_males_mothers_ID = c();
			for (male1 in seq(0, size(sampled_males)-1)) {
				sampled_males_mothers_ID = c(sampled_males_mothers_ID, sampled_males[male1].pedigreeParentIDs[0]);
			}
			sampled_males_mothers = sim.individualsWithPedigreeIDs(sampled_males_mothers_ID);
			
			relatives = c(sampled_males, sampled_females, sampled_males_mothers);
			for (i in relatives) {
				pedID = i.pedigreeID;
				writeFile("bash_Num_replicat/pedigreeID_village_father.txt", paste(asString(pedID), village, community.tick), append = T);
			}
			
			sim.treeSeqRememberIndividuals(relatives);
			
			// local group //
			females = groups.individuals[groups.individuals.sex == 'F' & groups.individuals.age > 0 & groups.individuals.age < 4];
			// sample a male
			grandfather = sample(males[males.age == 3], 1);

			// sons
			relMales = males.relatedness(grandfather);
			firstDegMalesIndex = which(relMales == 0.5);
			firstDegMales = males[firstDegMalesIndex];
			sons = firstDegMales[firstDegMales.age == 2];

			// paternal grandsons
			grandsons = c();
			if (size(sons) > 0) {
				for (son in sons) {
					relMales = males.relatedness(son);
					firstDegMalesIndex = which(relMales == 0.5);
					firstDegMales = males[firstDegMalesIndex];
					grandsons = c(grandsons, firstDegMales[firstDegMales.age == 1]);
				}
			}
			
			// wife
			couples = sim.getValue("couples");
			index = match(grandfather.pedigreeID, asInteger(couples[,3]));
			if (index == -1) {
				print("no wife because of unbalanced sex ratio");
				wife = c();
			}
			else {
				wife = sim.individualsWithPedigreeIDs(asInteger(couples[index, 4]));
			}
			
			// sons' wives
			sons_wives = c();
			if (size(sons) > 0) {
				for (son in sons) {
					index = match(son.pedigreeID, asInteger(couples[,3]));
					if (index == -1) {
						print("no wife because of unbalanced sex ratio");
					}
					else {
						sons_wives = c(sons_wives, sim.individualsWithPedigreeIDs(asInteger(couples[index, 4])));
					}
				}
			}

			// grandsons' wives
			grandsons_wives = c();
			if (size(grandsons) > 0) {
				for (grandson in grandsons) {
					index = match(grandson.pedigreeID, asInteger(couples[,3]));
					if (index == -1) {
						print("no wife because of unbalanced sex ratio");
					}
					else {
						grandsons_wives = c(grandsons_wives, sim.individualsWithPedigreeIDs(asInteger(couples[index, 4])));
					}
				}
			}

			// if females are burried with their husband
			femaleRelatives = unique(c(wife, sons_wives, grandsons_wives));
			
			// all related males
			maleRelatives = unique(c(grandfather, sons, grandsons));
			
			// males' mothers
			maleRelatives_mothers_ID = c();
			for (male1 in seq(0, size(maleRelatives)-1)) {
				maleRelatives_mothers_ID = c(maleRelatives_mothers_ID, maleRelatives[male1].pedigreeParentIDs[0]);
			}
			maleRelatives_mothers = sim.individualsWithPedigreeIDs(maleRelatives_mothers_ID);
			print(maleRelatives);
			print(maleRelatives_mothers);
			
			// compute male and female relatedness
			pairwise_relatednessM = c();
			pairwise_relatednessF = c();
			
			if (size(maleRelatives) > 1) {
				for (male1 in seq(0, size(maleRelatives)-2)) {
					other_males = maleRelatives[(male1 + 1): (size(maleRelatives) - 1)];
					rel = maleRelatives[male1].relatedness(other_males);
					pairwise_relatednessM = c(pairwise_relatednessM, rel);
				}
			}
			else {
				pairwise_relatednessM = c(0);
			}
			
			if (size(femaleRelatives) > 1) {
				for (female1 in seq(0, size(femaleRelatives)-2)) {
					other_females = femaleRelatives[(female1 + 1): (size(femaleRelatives) - 1)];
					rel = femaleRelatives[female1].relatedness(other_females);
					pairwise_relatednessF = c(pairwise_relatednessF, rel);
				}
			}
			else {
				pairwise_relatednessF = c(0);
			}
			
			// frequency of 1st, 2nd and 3rd degree relatedness
			relFreqM = size(pairwise_relatednessM[pairwise_relatednessM > 0])/size(pairwise_relatednessM);
			relFreqF = size(pairwise_relatednessF[pairwise_relatednessF > 0])/size(pairwise_relatednessF);
			
			// frequency of 1st degree relatedness
			relFirstM = size(pairwise_relatednessM[pairwise_relatednessM == 0.5])/size(pairwise_relatednessM);
			relFirstF = size(pairwise_relatednessF[pairwise_relatednessF == 0.5])/size(pairwise_relatednessF);
			
			// mean relatedness
			meanRelM = mean(pairwise_relatednessM);
			meanRelF = mean(pairwise_relatednessF);
			
			line = paste("bash_Num_replicat", community.tick, relFreqM, relFreqF, meanRelM, meanRelF, relFirstM, relFirstF, size(c(maleRelatives, femaleRelatives)));
			writeFile(paste0(output, "relatedness_patriline.txt"), line, append = T);
			
			relatives = c(maleRelatives, femaleRelatives, maleRelatives_mothers);
			for (i in relatives) {
				pedID = i.pedigreeID;
				writeFile("bash_Num_replicat/pedigreeID.txt", paste(asString(pedID), village, community.tick), append = T);
			}
			
			sim.treeSeqRememberIndividuals(relatives);
			
			/////// if females are burried with their father ////////
			females = sim.subpopulations.individuals[sim.subpopulations.individuals.sex == "F"];
			femaleRelatives = c();
			pairwise_relatednessF = c();
			// daughters
			relFemales = females.relatedness(grandfather);
			firstDegFemalesIndex = which(relFemales == 0.5);
			firstDegFemales = females[firstDegFemalesIndex];
			daughters = firstDegFemales[firstDegFemales.age == 2];
			
			// paternal granddaughters
			granddaughters = c();
			if (size(daughters) > 0) {
				for (son in sons) {
					relFemales = females.relatedness(son);
					firstDegFemalesIndex = which(relFemales == 0.5);
					firstDegFemales = females[firstDegFemalesIndex];
					granddaughters = c(granddaughters, firstDegFemales[firstDegFemales.age == 1]);
				}
			}

			femaleRelatives = unique(c(daughters, granddaughters));
			
			if (size(femaleRelatives) > 1) {
				for (female1 in seq(0, size(femaleRelatives)-2)) {
					other_females = femaleRelatives[(female1 + 1): (size(femaleRelatives) - 1)];
					rel = femaleRelatives[female1].relatedness(other_females);
					pairwise_relatednessF = c(pairwise_relatednessF, rel);
				}
			}
			else {
				pairwise_relatednessF = c(0);
			}
			
			// frequency of 1st, 2nd and 3rd degree relatedness
			relFreqF = size(pairwise_relatednessF[pairwise_relatednessF > 0])/size(pairwise_relatednessF);
			
			// frequency of 1st degree relatedness
			relFirstF = size(pairwise_relatednessF[pairwise_relatednessF == 0.5])/size(pairwise_relatednessF);
			
			// mean relatedness
			meanRelF = mean(pairwise_relatednessF);
			
			line = paste("bash_Num_replicat", community.tick, relFreqM, relFreqF, meanRelM, meanRelF, relFirstM, relFirstF, size(c(maleRelatives, femaleRelatives)));
			writeFile(paste0(output, "relatedness_patriline_father.txt"), line, append = T);
			
			relatives = c(maleRelatives, femaleRelatives, maleRelatives_mothers);
			for (i in relatives) {
				pedID = i.pedigreeID;
				writeFile("bash_Num_replicat/pedigreeID_father.txt", paste(asString(pedID), village, community.tick), append = T);
			}
			
			sim.treeSeqRememberIndividuals(relatives);

			for (group in groups) {
				pairwise_group_relatednessM = c();
				pairwise_group_relatednessF = c();
				pairwise_group_relatednessM_sampled = c();
				pairwise_group_relatednessF_sampled = c();
				males = group.individuals[group.individuals.sex == 'M' & group.individuals.age > 0];
				females = groups.individuals[groups.individuals.sex == 'F' & groups.individuals.age > 0];
				if (size(males) > 1 & size(females) > 1) {
					for (male1 in seq(0, size(males)-2)) {
						other_males = males[(male1 + 1): (size(males) - 1)];
						rel = males[male1].relatedness(other_males);
						pairwise_group_relatednessM = c(pairwise_group_relatednessM, rel);
					}
					
					for (female1 in seq(0, size(females)-2)) {
						other_females = females[(female1 + 1): (size(females) - 1)];
						rel = females[female1].relatedness(other_females);
						pairwise_group_relatednessF = c(pairwise_group_relatednessF, rel);
					}
				}
				
				else {
					next;
				}
				
				if (size(males) >= 5 & size(females) >= 5) {
					sampled_males = sample(males, 5);
					for (male1 in seq(0, size(sampled_males)-2)) {
						other_males = sampled_males[(male1 + 1): (size(sampled_males) - 1)];
						rel = sampled_males[male1].relatedness(other_males);
						pairwise_group_relatednessM_sampled = c(pairwise_group_relatednessM_sampled, rel);
					}
					sampleRelGroupFreqM = size(pairwise_group_relatednessM_sampled[pairwise_group_relatednessM_sampled > 0])/size(pairwise_group_relatednessM_sampled);
					sampleRelGroupFirstM = size(pairwise_group_relatednessM_sampled[pairwise_group_relatednessM_sampled == 0.5])/size(pairwise_group_relatednessM_sampled);
					sampleMeanGroupRelM = mean(pairwise_group_relatednessM_sampled);
					
					sampled_females = sample(females, 5);
					for (female1 in seq(0, size(sampled_females)-2)) {
						other_females = sampled_females[(female1 + 1): (size(sampled_females) - 1)];
						rel = sampled_females[female1].relatedness(other_females);
						pairwise_group_relatednessF_sampled = c(pairwise_group_relatednessF_sampled, rel);
					}
					sampleRelGroupFreqF = size(pairwise_group_relatednessF_sampled[pairwise_group_relatednessF_sampled > 0])/size(pairwise_group_relatednessF_sampled);
					sampleRelGroupFirstF = size(pairwise_group_relatednessF_sampled[pairwise_group_relatednessF_sampled == 0.5])/size(pairwise_group_relatednessF_sampled);
					sampleMeanGroupRelF = mean(pairwise_group_relatednessF_sampled);
				}
				
				else {
					sampleRelGroupFreqM = NAN;
					sampleRelGroupFreqF = NAN;
					sampleMeanGroupRelM = NAN;
					sampleMeanGroupRelF = NAN;
					sampleRelGroupFirstM = NAN;
					sampleRelGroupFirstF = NAN;
				}
				
				relGroupFreqM = size(pairwise_group_relatednessM[pairwise_group_relatednessM > 0])/size(pairwise_group_relatednessM);
				relGroupFreqF = size(pairwise_group_relatednessF[pairwise_group_relatednessF > 0])/size(pairwise_group_relatednessF);
				
				relGroupFirstM = size(pairwise_group_relatednessM[pairwise_group_relatednessM == 0.5])/size(pairwise_group_relatednessM);
				relGroupFirstF = size(pairwise_group_relatednessF[pairwise_group_relatednessF == 0.5])/size(pairwise_group_relatednessF);
				
				meanGroupRelM = mean(pairwise_group_relatednessM);
				meanGroupRelF = mean(pairwise_group_relatednessF);
				
				line = paste("bash_Num_replicat", community.tick, relGroupFreqM, relGroupFreqF, meanGroupRelM, meanGroupRelF, relGroupFirstM, relGroupFirstF,
					sampleRelGroupFreqM, sampleRelGroupFreqF, sampleMeanGroupRelM, sampleMeanGroupRelF, sampleRelGroupFirstM, sampleRelGroupFirstF);
				writeFile(paste0(output, "relatedness_group.txt"), line, append = T);
			}
		}
		generation = community.tick - 20000;
		filename = paste0('bash_Num_replicat/Sim_bash_Num_replicat_gen_', generation, '.trees');
		print(filename);
		sim.treeSeqOutput(path = filename);
	}
}